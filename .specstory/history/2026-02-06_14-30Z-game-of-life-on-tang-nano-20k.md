<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session 83e1433f-1e97-4ed3-a3a7-148f82e05d49 (2026-02-06 14:30Z) -->

# Game of life on Tang Nano 20K (2026-02-06 14:30Z)

_**User**_

# Game of Life on Tang Nano 20K — Project Brief

The Tang Nano 20K is a massive upgrade from what you were working with before. You've got **20,736 LUTs** and **15,552 DFFs** instead of the ~6,693 DFF limit you were fighting. Plus it has **HDMI out natively** via the onboard connector, same Gowin toolchain, and plenty of BRAM/PSRAM.

Here's the plan:

---

## The Vision

A **256×256 toroidal Game of Life** with 7 species (colors), running at ~30+ FPS, output over HDMI at 1080p (or 720p). The grid is rendered as scaled pixels so each cell is visible. The Tang Nano 20K makes this much more comfortable — no more agonizing over every DFF.

## Architecture Overview

**Three main modules:**

**`gol_engine.v`** — The update FSM. Iterates through all 65,536 cells each generation, reads 8 neighbors from RAM (toroidal wrap), applies Conway rules, writes the result to the opposite buffer. Double-buffered so display never sees partial updates.

**`video_source_gol.v`** — Maps HDMI pixel coordinates to grid coordinates, reads the display buffer, and outputs RGB based on species (0=dead/black, 1–7 = distinct colors). Handles layout: top info bar, grid area, bottom bar.

**`svo_hdmi.v`** (or equivalent top-level) — Generates HDMI timing signals (1080p or 720p), drives the TMDS output on the Tang Nano 20K's HDMI connector, manages clock domains (pixel clock from on-chip PLL), and triggers generation updates via `video_sof` (start-of-frame).

## Key Constraints (still apply)

- **Grid RAM in separate modules** (`gol_ram.v`): `reg [3:0] mem [0:65535]`, synchronous read/write, so Gowin infers PSRAM/BRAM — not DFFs. Never put large arrays in the FSM module.
- **Double buffering**: `ram_select` flips which bank is read (display) vs written (update). Swap ONLY on `video_sof`. Never write to the display bank.
- **1-cycle RAM read latency**: Address on cycle N → data on cycle N+1. The FSM must pipeline accordingly. Don't use "current cycle" read data for current cycle decisions.
- **Toroidal wrap**: x and y wrap with 8-bit unsigned arithmetic (256×256 grid, so `x-1` when x=0 becomes 255 automatically).
- **Address**: `addr = {y[7:0], x[7:0]}` — 16-bit, simply concatenate.

## What's Different on the 20K

- **DFF budget is ~15,552** instead of 6,693. Still keep RAM in dedicated modules, but the FSM can be a bit more comfortable — small counters, state registers, etc. are fine.
- **HDMI connector is onboard** — use Gowin's OSER10/ELVDS primitives or an open-source HDMI module (like the `svo_hdmi` approach from the previous project, or the HDMI examples from sipeed/TangNano-20K-example).
- **27 MHz crystal** on board; use the Gowin rPLL to generate pixel clock (74.25 MHz for 720p, 148.5 MHz for 1080p). 720p is the safer bet for timing closure.
- **PSRAM**: The 20K has 2× HyperRAM chips (64Mbit total), but for this project on-chip BRAM (41× B-SRAM blocks of 18Kbit each) is simpler and sufficient for 2× 64K×4-bit buffers.

## FSM Design (gol_engine)

States for processing each cell:
1. **READ_CENTER** — Read current cell from source bank. Set up first neighbor address.
2. **READ_NEIGHBORS** (8 cycles) — Pipeline: each cycle sets the next neighbor address while accumulating the count from the previous cycle's read. Use `same_species_count` and `any_alive_count` as needed for your species rules.
3. **APPLY_RULES** — Standard Conway: alive + (2 or 3 neighbors) → survive; dead + (exactly 3) → birth (inherit majority species or pick one). Write result to dest bank.
4. **ADVANCE** — Move to next cell. After all 65,536: signal done, wait for next SOF swap.

**Optimizations** (safe):
- Early exit: if neighbor count ≥ 4 during accumulation, skip remaining neighbors (cell dies regardless).
- Skip write: if new state == old state, don't write (dest bank retains previous gen's value since it was the display bank last frame — only valid with double buffering).

## Species / Color Rules

- Dead = 0, species 1–7.
- Birth: exactly 3 alive neighbors → new cell takes the majority species among those 3 (or any tiebreak rule you like).
- Survival: 2 or 3 alive neighbors → keep current species.
- Death: otherwise → 0.

## Video Output

- 720p (1280×720) is recommended. Each grid cell = 2×2 pixels gives a 512×512 pixel game area, centered with bars.
- Color palette: 8 entries (index 0 = black, 1–7 = distinct colors). Simple LUT, no computation.
- `gol_x = (pixel_x - GRID_OFFSET_X) >> 1`, same for y. Out-of-bounds pixels → black.

## File Structure

```
src/
  top.v              — Pin assignments, PLL, instantiate svo_hdmi
  svo_hdmi.v         — HDMI timing + TMDS encoding, update_interval, video_sof
  video_source_gol.v — Pixel-to-grid mapping, color LUT, layout
  gol_engine.v       — GoL FSM, double-buffer control
  gol_ram.v          — Simple synchronous 64K×4 RAM module (instantiate 2×)
  tmds_encoder.v     — TMDS 8b/10b (unless using Gowin primitives)
constraints.cst      — Pin constraints for Tang Nano 20K HDMI + clock
```

## Init / Seed

On reset, write a seed pattern (R-pentomino, acorn, or random via LFSR) into both RAM banks. An LFSR-based random fill with ~25% density makes for a great demo. Seed can be baked into the FSM's init state.

## Summary for the AI doing the implementation

> You're building Conway's Game of Life on a **Gowin GW2A-LV18PG256C8/I7** (Tang Nano 20K). 256×256 toroidal grid, 7 species, double-buffered in on-chip BRAM, HDMI 720p output. Read the DEV_GUIDE.md for pitfalls — especially: RAM in separate modules, 1-cycle read latency pipelining, swap on SOF only, no large arrays in the FSM. You have more DFFs than the old board but the same architectural rules apply. Start with `gol_ram.v`, then `gol_engine.v`, then video/HDMI integration. Test synthesis after each module to verify BRAM inference and DFF count.


---

_**Agent (model default, mode Agent)**_

<think><details><summary>Thought Process</summary>

The user has provided a detailed project brief for implementing Conway's Game of Life on a Tang Nano 20K FPGA. They want me to create a plan for this implementation. I'm in plan mode, so I should:

1. Explore the codebase to understand what already exists (DEV_GUIDE.md, any existing modules, Tang Nano 20K structure)
2. Check for existing HDMI/GoL code from "the previous project" they mention
3. Create a comprehensive plan that follows their architecture and constraints

Let me search the codebase to understand what's there and what needs to be built.
</details></think>

---


Exploring the codebase and any existing docs or modules to draft an implementation plan.


---

<tool-use data-tool-type="unknown" data-tool-name="list_dir_v2">
<details>
<summary>Tool use: **list_dir_v2**</summary>


Parameters:

```json
{
  "targetDirectory": "c:\\Users\\zombo\\Desktop\\Programming\\20kgol"
}
```
Result:

```json
{
  "directoryTreeRoot": {
    "absPath": "c:\\Users\\zombo\\Desktop\\Programming\\20kgol",
    "childrenDirs": [
      {
        "absPath": "c:\\Users\\zombo\\Desktop\\Programming\\20kgol\\.specstory",
        "childrenDirs": [
          {
            "absPath": "c:\\Users\\zombo\\Desktop\\Programming\\20kgol\\.specstory\\history",
            "childrenFiles": [
              {
                "name": "2026-02-06_14-30Z-game-of-life-on-tang-nano-20k.md"
              }
            ],
            "childrenWereProcessed": true
          }
        ],
        "childrenFiles": [
          {
            "name": ".gitignore"
          }
        ],
        "childrenWereProcessed": true
      }
    ],
    "childrenFiles": [
      {
        "name": ".cursorindexingignore"
      }
    ],
    "childrenWereProcessed": true
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="generic" data-tool-name="glob_file_search">
<details>
<summary>Tool use: **glob_file_search** • Searched codebase "undefined" • **2** results in **1** directory</summary>

Directory: **c:\Users\zombo\Desktop\Programming\20kgol** (2 files)

| File |
|------|
| `../.\.specstory\history\2026-02-06_14-30Z-game-of-life-on-tang-nano-20k.md` |
| `../.\.specstory\.what-is-this.md` |

</details>
</tool-use>

---

<tool-use data-tool-type="generic" data-tool-name="glob_file_search">
<details>
<summary>Tool use: **glob_file_search** • Searched codebase "undefined" • **0** result in **1** directory</summary>

Directory: **c:\Users\zombo\Desktop\Programming\20kgol** (0 file)

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>

No Verilog files yet and no DEV_GUIDE.md in the repo. The user mentioned "Read the DEV_GUIDE.md for pitfalls" — it might be something they expect to exist or will add. Let me check the specstory history for any referenced docs or prior project structure, and search for any constraints or example references (sipeed/TangNano-20K).
</details></think>

---





---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: c:\Users\zombo\Desktop\Programming\20kgol\.specstory\history\2026-02-06_14-30Z-game-of-life-on-tang-nano-20k.md</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: c:\Users\zombo\Desktop\Programming\20kgol\.specstory\.what-is-this.md</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "DEV_GUIDE|svo_hdmi|gol_engine|gol_ram",
  "path": "c:\\Users\\zombo\\Desktop\\Programming\\20kgol",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "DEV_GUIDE|svo_hdmi|gol_engine|gol_ram",
    "path": "c:\\Users\\zombo\\Desktop\\Programming\\20kgol",
    "outputMode": "content",
    "workspaceResults": {
      "c:\\Users\\zombo\\Desktop\\Programming\\20kgol": {
        "content": {
          "matches": [
            {
              "file": ".\\.specstory\\history\\2026-02-06_14-30Z-game-of-life-on-tang-nano-20k.md",
              "matches": [
                {
                  "lineNumber": 25,
                  "content": "**&#96;gol_engine.v&#96;** — The update FSM. Iterates through all 65,536 cells each generation, reads 8 neighbors from RAM (toroidal wrap), applies Conway rules, writes the result to the opposite buffer. Double-buffered so display never sees partial updates."
                },
                {
                  "lineNumber": 29,
                  "content": "**&#96;svo_hdmi.v&#96;** (or equivalent top-level) — Generates HDMI timing signals (1080p or 720p), drives the TMDS output on the Tang Nano 20K's HDMI connector, manages clock domains (pixel clock from on-chip PLL), and triggers generation updates via &#96;video_sof&#96; (start-of-frame)."
                },
                {
                  "lineNumber": 33,
                  "content": "- **Grid RAM in separate modules** (&#96;gol_ram.v&#96;): &#96;reg [3:0] mem [0:65535]&#96;, synchronous read/write, so Gowin infers PSRAM/BRAM — not DFFs. Never put large arrays in the FSM module."
                },
                {
                  "lineNumber": 42,
                  "content": "- **HDMI connector is onboard** — use Gowin's OSER10/ELVDS primitives or an open-source HDMI module (like the &#96;svo_hdmi&#96; approach from the previous project, or the HDMI examples from sipeed/TangNano-20K-example)."
                },
                {
                  "lineNumber": 46,
                  "content": "## FSM Design (gol_engine)"
                },
                {
                  "lineNumber": 75,
                  "content": "  top.v              — Pin assignments, PLL, instantiate svo_hdmi"
                },
                {
                  "lineNumber": 76,
                  "content": "  svo_hdmi.v         — HDMI timing + TMDS encoding, update_interval, video_sof"
                },
                {
                  "lineNumber": 78,
                  "content": "  gol_engine.v       — GoL FSM, double-buffer control"
                },
                {
                  "lineNumber": 79,
                  "content": "  gol_ram.v          — Simple synchronous 64K×4 RAM module (instantiate 2×)"
                },
                {
                  "lineNumber": 90,
                  "content": "&gt; You're building Conway's Game of Life on a **Gowin GW2A-LV18PG256C8/I7** (Tang Nano 20K). 256×256 toroidal grid, 7 species, double-buffered in on-chip BRAM, HDMI 720p output. Read the DEV_GUIDE.md for pitfalls — especially: RAM in separate modules, 1-cycle read latency pipelining, swap on SOF only, no large arrays in the FSM. You have more DFFs than the old board but the same architectural rules apply. Start with &#96;gol_ram.v&#96;, then &#96;gol_engine.v&#96;, then video/HDMI integration. Test synthesis after each module to verify BRAM inference and DFF count."
                }
              ]
            }
          ],
          "totalLines": 10,
          "totalMatchedLines": 10
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>

The workspace is essentially empty — no src/, no Verilog, no DEV_GUIDE.md. The brief is the only spec. I'll look up Tang Nano 20K pinout/HDMI and Gowin GW2A references to make the plan accurate, then create the plan. DEV_GUIDE.md is referenced but doesn't exist; the plan should either recommend creating it or note that the brief's constraints serve as the guide.
</details></think>

---


Checking for Tang Nano 20K pin/HDMI references and Gowin BRAM inference patterns:


---

<tool-use data-tool-type="search" data-tool-name="web_search">
<details>
            <summary>Tool use: **web_search** • Searched web `undefined` • **1** results</summary>
        
| Title | URL | Chunk |
|-------|-----|-------|
| Web search results for query: Tang Nano 20K GW2A-LV18PG256 HDMI pinout constraints Gowin |  | Links:<br/>1. [Lichee Tang Nano20K FPGA User Guide](https://spotpear.com/wiki/Sipeed-Lichee-Tang-Nano-20K-FPGA-GW2AR-18-QN88-GOAI-Gowin-HDMI-RISCV-Linux-Retro-Game-Open-Source.html)<br/>2. [Sipeed FPGA Tang Primer 20K Dock/Lite 128M DDR3 Development Board GW2A-LV18PG256C8/I7](https://spotpear.com/wiki/Sipeed-FPGA-Tang-Primer-20K-Dock-GW2A-LV18PG256C8_I7.html)<br/>3. [DK_START_GW2A-LV18PG256C8I7_V2.0 \| Gowin \| Starter Kits and Development Boards \| Support](https://www.gowinsemi.com/en/support/devkits_detail/31/)<br/>4. [Tang Nano 20K](https://deepwiki.com/sipeed/sipeed_wiki/4.1-tang-nano-20k)<br/>5. [GitHub - CasperDev/tangnano-hdmi: Demo Implementation of HDMI with Audio for Gowin TangNano 9k FPGA board](https://github.com/CasperDev/tangnano-hdmi)<br/><br/># Tang Nano 20K GW2A-LV18PG256 HDMI Pinout Information<br/><br/>The search results do not contain specific HDMI pinout constraints for the Tang Nano 20K GW2A-LV18PG256. However, here's what is available:<br/><br/>## Available Information<br/><br/>The Tang Nano 20K development boards use Gowin FPGA chips and support HDMI output.[1][2] The board includes a 27MHz crystal that generates the clock for HDMI display, and an onboard MS5351 clock generating chip that provides multiple clock signals.[1]<br/><br/>A reference implementation exists for HDMI with audio on Tang Nano boards, including the Tang Nano 20K, demonstrating HDMI 720p and 480p display capabilities.[5]<br/><br/>## What's Missing<br/><br/>The search results do not provide:<br/>- Specific pin assignments for HDMI signals (clock, data, ground pins)<br/>- I/O bank constraints for HDMI pins<br/>- Voltage or signaling constraints from the Gowin tool documentation<br/>- Differential pair requirements or routing constraints<br/><br/>To find this information, you would need to consult:<br/>1. The GW2A-LV18PG256 datasheet from Gowin<br/>2. The Tang Nano 20K schematic diagram<br/>3. Gowin EDA constraint files or example projects for the board<br/>4. The device's pinout documentation in the Gowin support database[3] |

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="web_search">
<details>
            <summary>Tool use: **web_search** • Searched web `undefined` • **1** results</summary>
        
| Title | URL | Chunk |
|-------|-----|-------|
| Web search results for query: Gowin FPGA synchronous RAM inference BRAM reg array 65536 |  | Links:<br/>1. [](https://cdn.gowinsemi.com.cn/UG285E.pdf)<br/>2. [GOWIN Semiconductor Corp.](https://www.gowinsemi.com/en/document/main/database/1748/?page=1)<br/>3. [GowinSynthesis](https://cdn.gowinsemi.com.cn/SUG550E.pdf)<br/>4. [How to Simulate VHDL when Using a Vendor's Tool Generated Instantiation Code?](https://electronics.stackexchange.com/questions/528436/how-to-simulate-vhdl-when-using-a-vendors-tool-generated-instantiation-code)<br/>5. [Search code, repositories, users, issues, pull requests...](https://github.com/YosysHQ/apicula/wiki/Yosys-%E2%80%90-synth_gowin)<br/><br/># Gowin FPGA Synchronous RAM Inference<br/><br/>Gowin FPGAs support RAM inference through both explicit instantiation and HDL inference methods.<br/><br/>## BRAM Architecture<br/><br/>Gowin provides Block SRAM (BSRAM) and Synchronous SRAM (SSRAM) primitives documented in the BSRAM & SSRAM User Guide.[1] These support various configurations for synchronous memory operations, though the exact specifications for 65536-bit configurations require consulting the detailed datasheet.<br/><br/>## RAM Inference Approach<br/><br/>Rather than instantiating primitives directly, the recommended approach is to **infer BRAM from HDL code**.[4] This involves:<br/><br/>- Writing memory as simple arrays that synthesis tools can recognize<br/>- Clocking the address and/or data signals to ensure synchronous operation<br/>- Using standard HDL patterns that your synthesis tool translates to BRAM<br/><br/>## Synthesis Tool Support<br/><br/>GowinSynthesis (the official Gowin synthesis tool) handles RAM inference automatically.[3] The open-source Yosys flow also supports Gowin FPGA synthesis with memory inference options, including flags like `-nobram` (force distributed RAM) and `-nolutram` (force block RAM).[5]<br/><br/>## Design Considerations<br/><br/>The Gowin BSRAM primitives support multiple port configurations (single-port, semi-dual-port, dual-port) with specific timing behaviors for read-after-write scenarios.[1][4] Consult the BSRAM User Guide (UG285) for detailed behavioral specifications when inferring these configurations.[1][2] |

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>

I have enough context. The repo is greenfield. I'll create a plan that:
1. Creates the file structure and optionally a DEV_GUIDE.md capturing the brief's pitfalls
2. Implements in order: gol_ram.v → gol_engine.v → video_source_gol.v → tmds_encoder.v → svo_hdmi.v → top.v → constraints.cst
3. Details FSM pipelining for 1-cycle latency, double-buffer swap on SOF, toroidal addressing, species rules, early exit/skip-write
4. Notes that Tang Nano 20K HDMI pins may need to be taken from Sipeed examples or schematic

Let me also quickly check if there's a sipeed TangNano-20K-example repo structure for HDMI.
</details></think>

---





---

<tool-use data-tool-type="search" data-tool-name="web_search">
<details>
            <summary>Tool use: **web_search** • Searched web `undefined` • **1** results</summary>
        
| Title | URL | Chunk |
|-------|-----|-------|
| Web search results for query: sipeed TangNano-20K-example HDMI github |  | Links:<br/>1. [GitHub - sipeed/TangNano-20K-example: TangNano-20K-example](https://github.com/sipeed/TangNano-20K-example)<br/>2. [Search code, repositories, users, issues, pull requests...](https://github.com/sipeed/TangNano-4K-example)<br/>3. [Tang Nano 20K](https://wiki.sipeed.com/hardware/en/tang/tang-nano-20k/nano-20k.html)<br/>4. [sipeed_wiki/docs/hardware/en/tang/tang-nano-20k/example/unbox.md at main · sipeed/sipeed_wiki](https://github.com/sipeed/sipeed_wiki/blob/main/docs/hardware/en/tang/tang-nano-20k/example/unbox.md)<br/>5. [Tang Nano 20K Unbox - Sipeed Wiki](https://wiki.sipeed.com/hardware/en/tang/tang-nano-20k/example/unbox.html)<br/><br/># Sipeed TangNano-20K HDMI Examples on GitHub<br/><br/>The Sipeed TangNano-20K-example repository on GitHub contains HDMI example projects for the TangNano-20K FPGA development board.[1]<br/><br/>## Repository Contents<br/><br/>The repository includes a dedicated `hdmi` folder among other example projects such as audio, LED, Linux, LiteX, RISC-V core, RGB LCD, and UART implementations.[1]<br/><br/>## Related Resources<br/><br/>For the TangNano-4K variant, there are additional HDMI examples available including camera-to-HDMI applications and various resolution demonstrations (720p and 2K).[2]<br/><br/>The default firmware for TangNano-20K boards uses LiteX, which can be downloaded from the same example repository.[4]<br/><br/>For detailed implementation guidance and IDE setup instructions, Sipeed provides wiki documentation at wiki.sipeed.com for getting started with these FPGA projects.[1] |

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>

Good. The plan can reference sipeed/TangNano-20K-example for HDMI pins and possibly TMDS/PLL. Creating the plan now.
</details></think>

---


Creating the implementation plan:


---

<tool-use data-tool-type="unknown" data-tool-name="create_plan">
<details>
<summary>Tool use: **create_plan**</summary>


Parameters:

```json
{
  "plan": "# Game of Life on Tang Nano 20K — Implementation Plan\n\n## Current state\n\n- **Workspace**: Empty. No &#96;src/&#96;, no Verilog, no &#96;DEV_GUIDE.md&#96;. The brief (and the specstory copy) is the only specification.\n- **DEV_GUIDE.md**: Referenced in the brief but not present. The plan assumes creating a short &#96;DEV_GUIDE.md&#96; that captures the stated pitfalls (RAM in separate modules, 1-cycle read latency, swap on SOF only, no large arrays in FSM) so they are in-repo.\n\n## Architecture (high level)\n\n&#96;&#96;&#96;mermaid\nflowchart LR\n  subgraph clk [Pixel clock domain]\n    PLL[PLL 27M to 74.25M]\n    Timing[HDMI timing 720p]\n    VideoSrc[video_source_gol]\n    TMDS[tmds_encoder]\n  end\n  subgraph engine [Engine clock same or derived]\n    FSM[gol_engine FSM]\n    RAM0[gol_ram bank 0]\n    RAM1[gol_ram bank 1]\n  end\n  SOF[video_sof]\n  PLL --&gt; Timing\n  Timing --&gt; VideoSrc\n  Timing --&gt; SOF\n  SOF --&gt; FSM\n  VideoSrc --&gt; RAM0\n  VideoSrc --&gt; RAM1\n  FSM --&gt; RAM0\n  FSM --&gt; RAM1\n  VideoSrc --&gt; TMDS\n  Timing --&gt; TMDS\n&#96;&#96;&#96;\n\n- **Double buffer**: &#96;ram_select&#96; chooses which bank is **display** (read by video) vs **update** (written by engine). Swap only on &#96;video_sof&#96;; engine never writes to the display bank.\n- **Address**: 16-bit &#96;addr = {y[7:0], x[7:0]}&#96;; toroidal wrap via 8-bit arithmetic (e.g. &#96;x-1&#96; when x=0 gives 255).\n\n---\n\n## 1. Project layout and docs\n\n- Create &#96;src/&#96; and the six Verilog files plus &#96;constraints.cst&#96; at repo root.\n- Add **DEV_GUIDE.md** (root or &#96;docs/&#96;) summarizing: (1) Grid RAM only in &#96;gol_ram.v&#96;, &#96;reg [3:0] mem [0:65535]&#96; for BRAM inference; (2) 1-cycle read latency — FSM must pipeline (address cycle N, use data at N+1); (3) Buffer swap only on &#96;video_sof&#96;; (4) No large arrays in the FSM module; (5) Build order and “synthesize after each module” check.\n\n---\n\n## 2. &#96;gol_ram.v&#96; — Grid RAM module\n\n- **Interface**: Single synchronous port: &#96;clk&#96;, &#96;addr [15:0]&#96;, &#96;we&#96;, &#96;din [3:0]&#96;, &#96;dout [3:0]&#96;.\n- **Implementation**: &#96;reg [3:0] mem [0:65535]&#96;; on posedge &#96;clk&#96;: if &#96;we&#96; then &#96;mem[addr] &lt;= din&#96;; assign &#96;dout = mem[addr]&#96; (or register &#96;dout&#96; one cycle later for explicit 1-cycle read latency — ensure same pattern is used consistently so engine and video align).\n- **Inference**: Use a single read/write port, synchronous write, synchronous read (registered output) so Gowin infers BRAM (B-SRAM). No logic in the RAM module beyond address/data/we; keep it a pure memory module.\n- **Usage**: Top level instantiates **two** instances (bank0, bank1). Engine and video will each drive/read the appropriate bank via a shared address/data interface or separate ports; see top-level wiring below.\n\n---\n\n## 3. &#96;gol_engine.v&#96; — Update FSM\n\n- **Clocking**: One clock (e.g. same as pixel clock or a divided clock); &#96;video_sof&#96; is the only sync to swap buffers.\n- **I/O**: \n  - Inputs: &#96;clk&#96;, &#96;rst&#96;, &#96;video_sof&#96;.\n  - Outputs: &#96;ram_select&#96; (which bank is display: 0 or 1), &#96;addr [15:0]&#96;, &#96;we&#96;, &#96;din [3:0]&#96; to **both** RAMs; each RAM’s &#96;addr&#96;/&#96;we&#96;/&#96;din&#96; is driven only when that bank is the **destination** (write) bank; read address is shared.\n  - RAM read data: two inputs &#96;dout_bank0&#96;, &#96;dout_bank1&#96;; FSM uses the one from the **source** (read) bank for current cell and neighbors.\n- **States** (per cell):\n  1. **READ_CENTER**: Set read address to current cell &#96;{y,x}&#96;; request center cell from source bank. No decision on this cycle (latency).\n  2. **READ_NEIGHBORS** (8 cycles): Pipeline — cycle N: present neighbor address; cycle N+1: add &#96;dout != 0&#96; to &#96;any_alive_count&#96;, and optionally same-species count. Optional **early exit**: if &#96;any_alive_count &gt;= 4&#96; during accumulation, skip remaining neighbor reads and go to APPLY_RULES (cell will die).\n  3. **APPLY_RULES**: Use registered center value and final neighbor counts. Conway: alive + (2 or 3) → survive (keep species); dead + exactly 3 → birth (majority species of the 3, or fixed tiebreak); else → 0. Optional **skip write**: if new state equals old center, omit write to dest bank.\n  4. **ADVANCE**: Increment cell index (e.g. 16-bit counter for 0..65535). If done (e.g. 65535), then idle until next &#96;video_sof&#96;; on &#96;video_sof&#96; flip &#96;ram_select&#96; and start next frame from cell 0.\n- **Pipelining**: Never use “this cycle’s” read data for “this cycle’s” write or state transition. Read at N, use result at N+1; center read in READ_CENTER is consumed in APPLY_RULES; neighbor reads are consumed one cycle after the address is applied.\n- **Toroidal neighbors**: For cell (x,y), 8 neighbors at (x±1, y±1) with 8-bit wrap: e.g. &#96;x_next = x + 1&#96;, &#96;x_prev = x - 1&#96; (no extra logic; Verilog 8-bit arithmetic wraps).\n- **Init**: Add an **INIT** state (or multi-cycle init): write seed into **both** banks (same addresses) so after first swap both banks are valid. Seed: e.g. LFSR-based random at ~25% density, or fixed pattern (R-pentomino, acorn). Init runs once after reset; then run the main FSM.\n\n---\n\n## 4. &#96;video_source_gol.v&#96; — Pixel to grid and colors\n\n- **Inputs**: Pixel coordinates (from timing), &#96;ram_select&#96;, and **read-only** access to the **display** bank (address in, data out with 1-cycle latency).\n- **Layout (720p)**: e.g. 1280×720. Grid 256×256 cells at 2×2 pixels each = 512×512 pixels. Center the grid: e.g. &#96;GRID_OFFSET_X = (1280 - 512)/2&#96;, &#96;GRID_OFFSET_Y = (720 - 512)/2&#96; (or similar); top/bottom bars for the rest.\n- **Mapping**: In grid area: &#96;gol_x = (pixel_x - GRID_OFFSET_X) &gt;&gt; 1&#96;, &#96;gol_y = (pixel_y - GRID_OFFSET_Y) &gt;&gt; 1&#96;. Address to display bank: &#96;addr = {gol_y[7:0], gol_x[7:0]}&#96;. Pipeline: present address one cycle before using species for color.\n- **Color**: 8-entry LUT: index 0 = black (dead); indices 1–7 = distinct RGB for species 1–7. Output RGB (e.g. 8b per channel or whatever &#96;tmds_encoder&#96; expects). Out-of-bounds (bars) → black.\n- **Timing**: Output valid during active video; sync with HDMI timing (de/active signals from &#96;svo_hdmi&#96;).\n\n---\n\n## 5. TMDS and HDMI\n\n- **tmds_encoder.v**: 8b/10b TMDS for one channel (or three instances for R, G, B). Input: 8-bit data, control bits, clk; output: 10-bit encoded serial (or parallel 10-bit if next stage serializes). Can follow open-source TMDS (e.g. from sipeed examples or common FPGA HDMI tutorials).\n- **svo_hdmi.v** (or equivalent):\n  - **Timing**: 720p (1280×720 @ 60 Hz): h_active=1280, h_sync, h_front/back porch; v_* similarly. Pixel clock 74.25 MHz from PLL.\n  - **Outputs**: &#96;hsync&#96;, &#96;vsync&#96;, &#96;de&#96; (data enable), &#96;pixel_x&#96;, &#96;pixel_y&#96;, &#96;video_sof&#96; (one pulse at start of each frame).\n  - **video_sof**: Assert for one pixel clock at the beginning of each frame; used by &#96;gol_engine&#96; to swap buffers and start the next generation.\n  - **Data path**: Combines timing + &#96;video_source_gol&#96; RGB → three TMDS encoders → serializers. On Tang Nano 20K, HDMI output uses the onboard connector; drive differential outputs (e.g. OSER10 + ELVDS or vendor primitives) as per Gowin/sipeed reference.\n- **Reference**: Use [sipeed/TangNano-20K-example](https://github.com/sipeed/TangNano-20K-example) (e.g. &#96;hdmi&#96; folder) for: 720p timing constants, HDMI pin assignments, and PLL (27 MHz → 74.25 MHz). Reuse or adapt their constraint names and pin list in &#96;constraints.cst&#96;.\n\n---\n\n## 6. Top and constraints\n\n- **top.v**:\n  - **PLL**: Input 27 MHz from crystal; output 74.25 MHz for pixel/HDMI (and optionally same or divided for &#96;gol_engine&#96;).\n  - **Instances**: 2× &#96;gol_ram&#96; (bank0, bank1); 1× &#96;gol_engine&#96;; 1× &#96;video_source_gol&#96;; 1× &#96;svo_hdmi&#96; (or equivalent); 3× &#96;tmds_encoder&#96; (or one module that instantiates three).\n  - **Wiring**: \n    - Engine: selects read bank by &#96;ram_select&#96;, writes only to the other bank; provides read address for current bank and receives &#96;dout&#96; from that bank; write port (addr, we, din) only to the destination bank.\n    - Video: receives &#96;ram_select&#96;, generates read address from pixel, reads from the **display** bank (same &#96;ram_select&#96; as “which bank display reads”), 1-cycle latency for &#96;dout&#96; into color LUT.\n  - **Pin assignments**: HDMI data and clock pins, 27 MHz clock input; from Sipeed schematic or example &#96;constraints.cst&#96;.\n- **constraints.cst**: Pin locations and I/O standards for GW2A-LV18PG256C8/I7: clock, HDMI (TMDS data + clock), any LEDs if desired. Copy/adapt from TangNano-20K-example.\n\n---\n\n## 7. Build order and verification\n\n1. **DEV_GUIDE.md** + **gol_ram.v** — Synthesize and check resource report: BRAM/BSRAM used for the two 64K×4 instances; no large DFF usage in RAM.\n2. **gol_engine.v** — Add FSM and wire to both RAMs in top; synthesize; confirm DFF count is reasonable (well under 15,552) and no unexpected BRAM in the FSM.\n3. **video_source_gol.v** + **tmds_encoder.v** + **svo_hdmi.v** — Integrate with timing and TMDS; synthesize.\n4. **top.v** + **constraints.cst** — Full build; timing closure (720p 74.25 MHz is the “safer” target from the brief).\n5. **Init/seed**: Implement and verify in simulation or on-board (LFSR or fixed pattern in both banks at reset).\n\n---\n\n## 8. Species and majority rule (detail)\n\n- Store cell state as 4 bits: 0 = dead, 1–7 = species.\n- **Birth** (center dead, exactly 3 neighbors): need majority among the 3 neighbor species. Options: (a) store the three species in the 8-neighbor read pipeline and compute majority in APPLY_RULES (e.g. compare and vote); (b) or simpler tiebreak: e.g. max of the three, or first-seen. Brief says “majority species among those 3 (or any tiebreak)” — implement majority if FSM budget allows, else a deterministic tiebreak.\n- **Survival**: 2 or 3 neighbors → keep current species (registered center value).\n- **Death**: else → write 0.\n\n---\n\n## 9. Files to create (summary)\n\n| Path | Purpose |\n|------|--------|\n| [DEV_GUIDE.md](DEV_GUIDE.md) | Pitfalls: RAM in separate module, 1-cycle latency, SOF swap, no big arrays; build order. |\n| [src/gol_ram.v](src/gol_ram.v) | Single-port sync 64K×4 RAM; BRAM inference. |\n| [src/gol_engine.v](src/gol_engine.v) | FSM: INIT, READ_CENTER, READ_NEIGHBORS (8), APPLY_RULES, ADVANCE; double-buffer control on SOF. |\n| [src/video_source_gol.v](src/video_source_gol.v) | Pixel→grid, 2×2 scaling, 8-color LUT, display-bank read. |\n| [src/tmds_encoder.v](src/tmds_encoder.v) | 8b/10b TMDS per channel. |\n| [src/svo_hdmi.v](src/svo_hdmi.v) | 720p timing, video_sof, pixel coords, TMDS + serialization. |\n| [src/top.v](src/top.v) | PLL, 2× gol_ram, gol_engine, video_source_gol, svo_hdmi, pin wiring. |\n| [constraints.cst](constraints.cst) | Tang Nano 20K pins (clock, HDMI); from Sipeed example. |\n\nNo existing code to modify; all files are new. After implementation, run synthesis after each major step to confirm BRAM inference and DFF usage as in the brief.\n",
  "name": "GoL Tang Nano 20K",
  "overview": "Implement a 256×256 toroidal Game of Life with 7 species on the Tang Nano 20K (GW2A-LV18PG256C8/I7): double-buffered grid in BRAM, update FSM with pipelined neighbor reads, 720p HDMI output via TMDS, and seed init. Build order: gol_ram → gol_engine → video/HDMI → top and constraints."
}
```
Additional data:

```json
{
  "reviewData": {
    "status": "Requested",
    "selectedOption": "none",
    "isShowingInput": false
  },
  "planUri": "file:///c%3A/Users/zombo/.cursor/plans/gol_tang_nano_20k_245246c2.plan.md",
  "hasOpenedEditor": true
}
```
Result:

```json
{
  "rejected": {}
}
```
Status: **completed**


</details>
</tool-use>

---

_**User**_

we should be doing this in segments and tdd ion parts to confirm what is working 

---

_**Agent (model default, mode Agent)**_

<think><details><summary>Thought Process</summary>

The user wants to adjust the plan to:
1. Do the work in segments (incremental delivery)
2. Use TDD (test-driven development) or "tdd i</details></think>

---

